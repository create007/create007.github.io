<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MXIC和XTX存储介质区别</title>
    <link href="/2025/09/21/MXIC%E5%92%8CXTX%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/09/21/MXIC%E5%92%8CXTX%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table><thead><tr><th>项目</th><th>MXIC NAND</th><th>XTX NAND</th></tr></thead><tbody><tr><td>常见容量</td><td>1Gb、2Gb、4Gb（如 MX35LF1G、MX35LF2G）</td><td>1Gb、2Gb、4Gb（如 XT61M 系列）</td></tr><tr><td>接口类型</td><td>串行 NAND（SPI NAND）为主</td><td>串行 NAND（SPI NAND）为主</td></tr><tr><td>工作电压</td><td>1.8V 或 3.3V</td><td>1.8V 或 3.3V</td></tr><tr><td>ECC 支持</td><td>内置 8-bit ECC</td><td>内置 8-bit ECC</td></tr><tr><td>封装形式</td><td>WSON、BGA 等</td><td>BGA-162 为主（如 XT61M2G8D2TA-B8BEA）</td></tr></tbody></table><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><table><thead><tr><th>应用</th><th>MXIC</th><th>XTX</th></tr></thead><tbody><tr><td>工业控制</td><td>✅ 高可靠性</td><td>❌ 不推荐</td></tr><tr><td>智能家居</td><td>✅</td><td>✅</td></tr><tr><td>摄像头模组</td><td>✅</td><td>✅（MCP 优势明显）</td></tr><tr><td>车载电子</td><td>✅（符合车规）</td><td>❌ 一般不用于车载</td></tr></tbody></table><h2 id="应用推荐"><a href="#应用推荐" class="headerlink" title="应用推荐"></a>应用推荐</h2><table><thead><tr><th>需求</th><th>推荐品牌</th></tr></thead><tbody><tr><td>成本敏感、空间受限（如摄像头）</td><td>✅ XTX（MCP 产品）</td></tr><tr><td>高可靠性、工业&#x2F;车载用途</td><td>✅ MXIC</td></tr><tr><td>独立 NAND、灵活设计</td><td>✅ MXIC</td></tr><tr><td>一体化解决方案（NAND+RAM）</td><td>✅ XTX</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uvc和uac区别</title>
    <link href="/2025/09/21/uvc%E5%92%8Cuac%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/09/21/uvc%E5%92%8Cuac%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>特性</th><th>UVC（USB Video Class）</th><th>UAC（USB Audio Class）</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>视频流传输（摄像头、摄像机等）</td><td>音频流传输（麦克风、耳机、声卡等）</td></tr><tr><td><strong>数据类型</strong></td><td>视频帧（如 MJPEG、H.264、YUV）</td><td>音频采样（如 PCM、AAC）</td></tr><tr><td><strong>设备示例</strong></td><td>USB 摄像头、网络摄像头</td><td>USB 麦克风、USB 耳机、外置声卡</td></tr><tr><td><strong>控制内容</strong></td><td>分辨率、帧率、亮度、对焦等</td><td>音量、采样率、静音、增益等</td></tr><tr><td><strong>协议版本</strong></td><td>UVC 1.1、1.5 等</td><td>UAC 1.0、2.0、3.0 等</td></tr><tr><td><strong>是否支持同步传输</strong></td><td>支持（ISO 传输）</td><td>支持（ISO 或异步传输）</td></tr><tr><td><strong>操作系统支持</strong></td><td>Windows、Linux、macOS 免驱</td><td>Windows、Linux、macOS 免驱</td></tr></tbody></table><ul><li>UVC 是“USB 摄像头标准”，</li><li>UAC 是“USB 音频设备标准”。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux_内存</title>
    <link href="/2025/09/21/linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2025/09/21/linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-内存"><a href="#linux-内存" class="headerlink" title="linux 内存"></a>linux 内存</h1><h2 id="VSZ"><a href="#VSZ" class="headerlink" title="VSZ"></a>VSZ</h2><p>VSZ（Virtual Size）表示进程使用的虚拟内存的大小，单位通常是千字节（KB）。虚拟内存是操作系统用来扩展物理内存的一种技术，它允许进程使用比物理内存更多的内存空间。VSZ包括了进程的代码、数据、堆栈以及共享库等占用的内存空间。VSZ并不包括磁盘上的交换空间（swap space），它仅包括进程在内存中占用的部分。如果需要查看包括交换空间在内的总内存使用情况，可以查看RSS（Resident Set Size），它表示进程实际占用的物理内存大小。</p><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>du（disk usage）命令在Linux系统中用于估计文件或目录在磁盘上的使用空间</p><p><code>du -sh /tmp/*</code></p><ul><li>du：命令本身，用于查看磁盘使用情况。</li><li>-s：（summarize）汇总选项，表示仅显示每个指定目录的总磁盘使用量，而不是列出目录中每个子目录和文件的磁盘使用量。</li><li>-h：（human-readable）易读选项，表示以易读的格式显示大小（如KB、MB、GB等），而不是默认的字节数。</li><li>&#x2F;tmp&#x2F;<em>：指定&#x2F;tmp目录下的所有文件和目录作为du命令的参数。这里的</em>是一个通配符，代表&#x2F;tmp目录下的所有内容。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emc_engineer</title>
    <link href="/2025/09/21/emc-engineer/"/>
    <url>/2025/09/21/emc-engineer/</url>
    
    <content type="html"><![CDATA[<h1 id="EMC"><a href="#EMC" class="headerlink" title="EMC"></a>EMC</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>电磁兼容（Electromagnetic Compatibility，简称EMC）是指设备或系统在其电磁环境中能正常工作，并且不会对环境中的任何设备产生不能承受的电磁干扰的能力。简单来说，EMC 确保电子设备在正常工作时不会对其他设备造成干扰，同时也能够抵抗来自其他设备的电磁干扰。</p><ol><li>EMI（Electromagnetic Interference） - 电磁干扰，指设备在正常工作时可能对其他设备产生的干扰。这包括传导干扰和辐射干扰。</li><li>EMS（Electromagnetic Susceptibility） - 电磁敏感度，指设备对外界电磁干扰的抵抗能力。</li></ol><h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><ul><li>传导干扰测试（Conducted Emission）</li><li>辐射干扰测试（Radiated Emission）</li><li>静电放电抗扰度测试（ESD）</li><li>快速脉冲群抗扰度测试（EFT）</li><li>浪涌抗扰度测试（Surge）</li><li>电压跌落抗扰度测试（Dips）</li></ul><h2 id="工程师职责"><a href="#工程师职责" class="headerlink" title="工程师职责"></a>工程师职责</h2><ol><li><p>EMC 设计与评估<br>在产品开发初期参与 EMC 设计，评估潜在电磁干扰风险，指导硬件、PCB Layout 和结构工程师进行 EMC 优化设计。</p></li><li><p>EMC 测试与整改<br>制定测试计划，执行 EMI（电磁干扰）和 EMS（电磁抗扰度）测试，分析测试数据，定位问题并提出整改方案。</p></li><li><p>认证与标准解读<br>熟悉并应用国际&#x2F;国家 EMC 标准（如 CISPR、ISO、IEC、GB、FCC 等），负责产品认证过程中的 EMC 问题解决。</p></li><li><p>技术文档与规范制定<br>编写 EMC 测试报告、设计规范、整改案例库，推动企业内部的 EMC 设计流程标准化。</p></li><li><p>跨部门协作与培训<br>为研发团队提供 EMC 技术支持，参与设计评审，组织内部培训，提高团队 EMC 意识与能力</p></li></ol><h2 id="工程师掌握技能"><a href="#工程师掌握技能" class="headerlink" title="工程师掌握技能"></a>工程师掌握技能</h2><ul><li>测试设备：频谱仪、示波器、EMI 接收机、静电放电发生器、浪涌测试仪等；</li><li>设计工具：PADS、Altium Designer、Cadence 等 PCB 设计工具；</li><li>仿真工具：ANSYS HFSS、CST、SIwave 等 EMC 仿真平台；</li><li>标准体系：CISPR 25、ISO 7637、ISO 11452、IEC 61000、GB&#x2F;T 18387 等。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>blog_generate</title>
    <link href="/2025/09/21/blog-generate/"/>
    <url>/2025/09/21/blog-generate/</url>
    
    <content type="html"><![CDATA[<h1 id="blog-generate"><a href="#blog-generate" class="headerlink" title="blog_generate"></a>blog_generate</h1><p>hexo generate step</p><ol><li>hexo init</li><li>hexo new “blog_name”</li><li>hexo generate</li><li>hexo server</li></ol><h1 id="blog-deploy"><a href="#blog-deploy" class="headerlink" title="blog deploy"></a>blog deploy</h1><ol><li>hexo clean</li><li>hexo generate</li><li>hexo deploy</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>operate_system</title>
    <link href="/2025/05/18/operate-system/"/>
    <url>/2025/05/18/operate-system/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rockchip_soc_debug</title>
    <link href="/2025/05/07/rockchip-soc-debug/"/>
    <url>/2025/05/07/rockchip-soc-debug/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍-rk-平台常用调式手段"><a href="#介绍-rk-平台常用调式手段" class="headerlink" title="介绍 rk 平台常用调式手段"></a>介绍 rk 平台常用调式手段</h1><h2 id="venc"><a href="#venc" class="headerlink" title="venc"></a>venc</h2><h3 id="查看编码器频率"><a href="#查看编码器频率" class="headerlink" title="查看编码器频率"></a>查看编码器频率</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span>  /sys/kernel/debug/clk/clk_rkvenc0_core/clk_rate<br><span class="hljs-built_in">cat</span>  /sys/kernel/debug/clk/clk_rkvenc1_core/clk_rate<br></code></pre></td></tr></table></figure><h2 id="isp"><a href="#isp" class="headerlink" title="isp"></a>isp</h2><h3 id="直通模式和半直通模式"><a href="#直通模式和半直通模式" class="headerlink" title="直通模式和半直通模式"></a>直通模式和半直通模式</h3><p><img src="/img/rockchip/isp_readback.png" alt="官方解释"></p><p>aiq 配置回读模式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> normal_no_read_back=0<br></code></pre></td></tr></table></figure><p>media 拓扑断开isp和cif链接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">media-ctl -d /dev/media1 -l  &amp;apos;<span class="hljs-string">&quot;rkcif-mipi-lvds&quot;</span>:0-&gt;<span class="hljs-string">&quot;rkisp-isp-subdev&quot;</span>:0[0]&amp;apos;  //将rkcif-mipi-lvds4和lvds4断开<br>media-ctl -d /dev/media1 -l  &amp;apos;<span class="hljs-string">&quot;rkisp_rawrd2_s&quot;</span>:0-&gt;<span class="hljs-string">&quot;rkisp-isp-subdev&quot;</span>:0[1]&amp;apos;  //将media3和rawrd2连接<br></code></pre></td></tr></table></figure><h2 id="ddr"><a href="#ddr" class="headerlink" title="ddr"></a>ddr</h2><h3 id="设置-ddr-频率"><a href="#设置-ddr-频率" class="headerlink" title="设置 ddr 频率"></a>设置 ddr 频率</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /sys/class/devfreq/dmc/available_frequencies<br><span class="hljs-built_in">echo</span> userspace &gt; /sys/class/devfreq/dmc/governor<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$freq</span> &gt; /sys/class/devfreq/dmc/userspace/set_freq<br></code></pre></td></tr></table></figure><h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><h3 id="配置-cpu-频率"><a href="#配置-cpu-频率" class="headerlink" title="配置 cpu 频率"></a>配置 cpu 频率</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> userspace &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>  &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux_debug</title>
    <link href="/2025/05/07/linux-debug/"/>
    <url>/2025/05/07/linux-debug/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-文件系统基本使用"><a href="#linux-文件系统基本使用" class="headerlink" title="linux 文件系统基本使用"></a>linux 文件系统基本使用</h1><h2 id="proc-iomem"><a href="#proc-iomem" class="headerlink" title="&#x2F;proc&#x2F;iomem"></a>&#x2F;proc&#x2F;iomem</h2><p>&#x2F;proc&#x2F;iomem 是一个 虚拟文件，用于记录系统中 物理内存和 I&#x2F;O 内存区域的映射信息。它展示了内核管理的所有物理地址空间的分配情况，包括 RAM、ROM、设备寄存器（MMIO）、PCI 设备内存等。通过这个信息也可以看设备有没有注册。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>code_debug</title>
    <link href="/2025/05/07/code-debug/"/>
    <url>/2025/05/07/code-debug/</url>
    
    <content type="html"><![CDATA[<h1 id="代码常用调式方式"><a href="#代码常用调式方式" class="headerlink" title="代码常用调式方式"></a>代码常用调式方式</h1><h2 id="打印调用堆栈"><a href="#打印调用堆栈" class="headerlink" title="打印调用堆栈"></a>打印调用堆栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execinfo.h&gt;</span>  <span class="hljs-comment">// for backtrace</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_STACK_FRAMES 128</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_stack_trace</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">void</span> *stack_frames[MAX_STACK_FRAMES];<br>    <span class="hljs-type">int</span> num_frames = backtrace(stack_frames, MAX_STACK_FRAMES);<br>    <span class="hljs-type">char</span> **symbols = backtrace_symbols(stack_frames, num_frames);<br><br>    <span class="hljs-keyword">if</span> (symbols == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;backtrace_symbols&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Call stack:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_frames; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, symbols[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(symbols);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_c</span><span class="hljs-params">()</span> &#123;<br>    print_stack_trace();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_b</span><span class="hljs-params">()</span> &#123;<br>    func_c();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_a</span><span class="hljs-params">()</span> &#123;<br>    func_b();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    func_a();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>build:<br>gcc -rdynamic -o stack_trace stack_trace.c  # `-rdynamic` 确保函数名可解析<br>./stack_trace<br><br>run:<br>Call <span class="hljs-built_in">stack</span>:<br>./stack_trace(print_stack_trace+<span class="hljs-number">0x1f</span>) [<span class="hljs-number">0x55a3b2d8b1af</span>]<br>./stack_trace(func_c+<span class="hljs-number">0xe</span>) [<span class="hljs-number">0x55a3b2d8b1ee</span>]<br>./stack_trace(func_b+<span class="hljs-number">0xe</span>) [<span class="hljs-number">0x55a3b2d8b201</span>]<br>./stack_trace(func_a+<span class="hljs-number">0xe</span>) [<span class="hljs-number">0x55a3b2d8b214</span>]<br>./stack_trace(main+<span class="hljs-number">0xe</span>) [<span class="hljs-number">0x55a3b2d8b227</span>]<br>/lib/x86_64-linux-gnu/libc.so.<span class="hljs-number">6</span>(__libc_start_main+<span class="hljs-number">0xf3</span>) [<span class="hljs-number">0x7f8c3a3a0083</span>]<br>./stack_trace(_start+<span class="hljs-number">0x2e</span>) [<span class="hljs-number">0x55a3b2d8b0ae</span>]<br></code></pre></td></tr></table></figure><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h2 id="内核打印堆栈"><a href="#内核打印堆栈" class="headerlink" title="内核打印堆栈"></a>内核打印堆栈</h2><p>dump_stack()</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mem_leak</title>
    <link href="/2025/05/07/mem-leak/"/>
    <url>/2025/05/07/mem-leak/</url>
    
    <content type="html"><![CDATA[<h1 id="排查内存泄露方式"><a href="#排查内存泄露方式" class="headerlink" title="排查内存泄露方式"></a>排查内存泄露方式</h1><h2 id="确定泄露情况"><a href="#确定泄露情况" class="headerlink" title="确定泄露情况"></a>确定泄露情况</h2><p>通过 cat &#x2F;proc&#x2F;meminfo 查看 avalible mem 是否一直在减少</p><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="代码做静态检查"><a href="#代码做静态检查" class="headerlink" title="代码做静态检查"></a>代码做静态检查</h3><p>如使用cppcheck</p><h3 id="本地运行实时检查"><a href="#本地运行实时检查" class="headerlink" title="本地运行实时检查"></a>本地运行实时检查</h3><p>可根据情况选择 vailgrand，asan，tcmalloc</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>analysis_crash</title>
    <link href="/2025/05/07/analysis-crash/"/>
    <url>/2025/05/07/analysis-crash/</url>
    
    <content type="html"><![CDATA[<h1 id="常见崩溃问题分析"><a href="#常见崩溃问题分析" class="headerlink" title="常见崩溃问题分析"></a>常见崩溃问题分析</h1><h2 id="崩溃在内核"><a href="#崩溃在内核" class="headerlink" title="崩溃在内核"></a>崩溃在内核</h2><p>根据堆栈分析具体行号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">arm-linux-gnueabihf-addr2line -e libx.so <span class="hljs-number">0x704da7</span><br></code></pre></td></tr></table></figure><p>使用 gdb 加载符号表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gdb <span class="hljs-title function_">vmlinux</span><br><span class="hljs-params">(gdb)</span> <span class="hljs-built_in">list</span> *<span class="hljs-params">(&lt;function_name&gt;+<span class="hljs-number">0</span>x&lt;offset&gt;)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>老薛的猫</title>
    <link href="/2025/05/05/test/"/>
    <url>/2025/05/05/test/</url>
    
    <content type="html"><![CDATA[<h1 id="关于即死又活薛定谔的描述"><a href="#关于即死又活薛定谔的描述" class="headerlink" title="关于即死又活薛定谔的描述"></a>关于即死又活薛定谔的描述</h1><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>薛定谔的猫是一个著名的思想实验，由奥地利物理学家埃尔温·薛定谔在1935年提出，旨在探讨量子力学中的哥本哈根解释所引发的一些奇特后果。这个实验描述了一只假想的猫，在一个封闭的盒子里，与一瓶毒药和一个放射性原子源放在一起。根据量子力学的原理，如果原子核发生衰变，则会触发释放毒药的机制，导致猫死亡；如果原子核没有衰变，则猫存活。</p><p>按照量子力学中的叠加态概念，在盒子未被打开、系统未被观测之前，这个系统可以同时处于两种状态的叠加：即原子核既衰变了又没有衰变，相应的，猫既是死的又是活的。这种状态被称为量子叠加态。</p><p>这个思想实验揭示了微观粒子的行为如何在宏观世界中产生看似荒谬的结果，并挑战了我们对现实本质的理解。它强调了在量子力学中测量的重要性——只有当我们观察或测量时，系统的波函数才会“坍缩”到一个确定的状态（在这种情况下，确定猫是死还是活）。</p><p>通过薛定谔的猫这一比喻，薛定谔希望指出量子理论在应用到日常尺度上的物体时出现的问题，以及需要更加完善的解释来理解量子现象如何过渡到经典物理学的现象。这促进了对于量子力学基础问题的更多讨论和研究。</p><ul><li>为喵界发声，在喵界的角度薛定谔也是即死又活的！！！</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>你好</title>
    <link href="/2019/10/10/hello-world/"/>
    <url>/2019/10/10/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="复活节"><a href="#复活节" class="headerlink" title="复活节"></a>复活节</h1>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
